**1. Problem Understanding**

A robot starts at $(0, 0)$ and must reach exactly $(X, Y)$ using discrete ticks
$i = 1, 2, 3, \dots$.

- On odd ticks, it can only increase $X$ (move east).
- On even ticks, it can only increase $Y$ (move north).
- On tick $i$, it chooses an integer distance $d$ such that
  $$
  0 \le d \le \min(K, i)
  $$
  and moves exactly $d$ along the allowed axis.
- Choosing $d = 0$ is allowed, so extra ticks may be spent without moving.

For each test case, we must output the minimum number of ticks needed to land
exactly on $(X, Y)$.

**2. Optimal Approach**

**Observation 1: Odd and even ticks control different axes.**  
Within the first $n$ ticks:

- The number of odd ticks is
  $$
  m_x = \left\lceil \frac{n}{2} \right\rceil
  $$
- The number of even ticks is
  $$
  m_y = \left\lfloor \frac{n}{2} \right\rfloor
  $$

Odd ticks contribute only to $X$, and even ticks contribute only to $Y$.

**Observation 2: It is enough to compare with maximum possible sums.**  
For one axis, if you have moves where the increment can be any integer in
$[0, c_1], [0, c_2], \dots, [0, c_m]$, then every integer sum from
$0$ to $\sum c_j$ is achievable. Therefore, for a fixed $n$, reaching
$(X, Y)$ is possible if and only if:
$$
C_x(n) \ge X \quad \text{and} \quad C_y(n) \ge Y
$$
where $C_x(n)$ and $C_y(n)$ are the maximum achievable distances along $X$
and $Y$ in $n$ ticks.

**Observation 3: Compute capacities in \(O(1)\) with closed forms.**

- Odd indices are $1, 3, 5, \dots, 2m_x - 1$. The number of odd values
  $\le K$ is $\left\lfloor \frac{K+1}{2} \right\rfloor$.
  Let
  $$
  p_x = \min\left(m_x, \left\lfloor \frac{K+1}{2} \right\rfloor\right)
  $$
  Then
  $$
  C_x(n) = p_x^2 + (m_x - p_x)\cdot K
  $$

- Even indices are $2, 4, 6, \dots, 2m_y$. The number of even values
  $\le K$ is $\left\lfloor \frac{K}{2} \right\rfloor$.
  Let
  $$
  p_y = \min\left(m_y, \left\lfloor \frac{K}{2} \right\rfloor\right)
  $$
  Then
  $$
  C_y(n) = p_y(p_y+1) + (m_y - p_y)\cdot K
  $$

**Observation 4: Feasibility is monotone in $n$.**  
If $(X, Y)$ is reachable in $n$ ticks, it is also reachable in any larger
number of ticks by using extra ticks with $d = 0$. So we can:

1. Double an upper bound until feasible.
2. Binary search for the smallest feasible $n$.

**3. Code**
```python
"""
Reference solution for the alternating-axis movement problem.

For each test case (X, Y, K), compute the minimum number of ticks needed to
reach exactly (X, Y), where odd ticks add to X, even ticks add to Y, and on
tick i the added distance d satisfies 0 <= d <= min(K, i).
"""
import sys


def compute_max_x_distance(tick_count: int, limit_k: int) -> int:
    """
    Compute the maximum X distance achievable within the first tick_count ticks.

    Args:
        tick_count: Total number of ticks available.
        limit_k: Global cap K on the per-tick movement.

    Returns:
        The maximum possible total increase in X after tick_count ticks.
    """
    odd_tick_count = (tick_count + 1) // 2
    warm_odd_count = (limit_k + 1) // 2
    warm_used = min(odd_tick_count, warm_odd_count)

    warm_sum = warm_used * warm_used
    capped_sum = (odd_tick_count - warm_used) * limit_k
    return warm_sum + capped_sum


def compute_max_y_distance(tick_count: int, limit_k: int) -> int:
    """
    Compute the maximum Y distance achievable within the first tick_count ticks.

    Args:
        tick_count: Total number of ticks available.
        limit_k: Global cap K on the per-tick movement.

    Returns:
        The maximum possible total increase in Y after tick_count ticks.
    """
    even_tick_count = tick_count // 2
    warm_even_count = limit_k // 2
    warm_used = min(even_tick_count, warm_even_count)

    warm_sum = warm_used * (warm_used + 1)
    capped_sum = (even_tick_count - warm_used) * limit_k
    return warm_sum + capped_sum


def is_reachable_in_ticks(
    tick_count: int,
    target_x: int,
    target_y: int,
    limit_k: int,
) -> bool:
    """
    Check whether (target_x, target_y) is reachable in at most tick_count ticks.

    Args:
        tick_count: Candidate number of ticks.
        target_x: Required final X coordinate.
        target_y: Required final Y coordinate.
        limit_k: Global cap K on the per-tick movement.

    Returns:
        True if the target is reachable within tick_count ticks, otherwise False.
    """
    max_x_distance = compute_max_x_distance(tick_count, limit_k)
    max_y_distance = compute_max_y_distance(tick_count, limit_k)
    return max_x_distance >= target_x and max_y_distance >= target_y


def find_minimum_ticks(target_x: int, target_y: int, limit_k: int) -> int:
    """
    Find the minimum number of ticks required to reach exactly (target_x, target_y).

    Args:
        target_x: Required final X coordinate.
        target_y: Required final Y coordinate.
        limit_k: Global cap K on the per-tick movement.

    Returns:
        The minimum tick count needed.
    """
    if target_x == 0 and target_y == 0:
        return 0

    lower_bound_ticks = 0
    upper_bound_ticks = 1
    while not is_reachable_in_ticks(
        upper_bound_ticks,
        target_x,
        target_y,
        limit_k,
    ):
        upper_bound_ticks <<= 1

    while lower_bound_ticks + 1 < upper_bound_ticks:
        middle_ticks = lower_bound_ticks + (
            (upper_bound_ticks - lower_bound_ticks) // 2
        )
        if is_reachable_in_ticks(middle_ticks, target_x, target_y, limit_k):
            upper_bound_ticks = middle_ticks
        else:
            lower_bound_ticks = middle_ticks

    return upper_bound_ticks


def main() -> None:
    """
    Read input, solve all test cases, and write the results.

    Input format:
        t
        X Y K
        X Y K
        ...

    Output format:
        One line per test case: the minimum required ticks.
    """
    input_stream = sys.stdin.buffer
    first_line = input_stream.readline().split()
    test_case_count = int(first_line[0])

    output_lines = []
    for _ in range(test_case_count):
        target_x_str, target_y_str, limit_k_str = input_stream.readline().split()
        target_x = int(target_x_str)
        target_y = int(target_y_str)
        limit_k = int(limit_k_str)

        answer_ticks = find_minimum_ticks(target_x, target_y, limit_k)
        output_lines.append(str(answer_ticks))

    sys.stdout.write("\n".join(output_lines))


if __name__ == "__main__":
    main()
```

**4. Code Explanation**

For a candidate number of ticks `tick_count = n`, we compute:

- `compute_max_x_distance(n, limit_k)` which equals
  $$
  C_x(n)=\sum_{\substack{1\le i\le n \\ i\ \text{odd}}}\min(K,i)
  $$
  but using the closed form:
  $$
  C_x(n)=p_x^2+(m_x-p_x)\cdot K
  $$
  where $m_x=\left\lceil \frac{n}{2}\right\rceil$ and
  $p_x=\min\left(m_x,\left\lfloor\frac{K+1}{2}\right\rfloor\right)$.

- `compute_max_y_distance(n, limit_k)` which equals
  $$
  C_y(n)=\sum_{\substack{1\le i\le n \\ i\ \text{even}}}\min(K,i)
  $$
  using:
  $$
  C_y(n)=p_y(p_y+1)+(m_y-p_y)\cdot K
  $$
  where $m_y=\left\lfloor \frac{n}{2}\right\rfloor$ and
  $p_y=\min\left(m_y,\left\lfloor\frac{K}{2}\right\rfloor\right)$.

Then `is_reachable_in_ticks` checks whether both capacities cover the targets:
$$
C_x(n) \ge X \quad \text{and} \quad C_y(n) \ge Y
$$

Since this condition is monotone in $n$, `find_minimum_ticks` first doubles an
upper bound until it becomes feasible, then binary searches to find the
smallest feasible tick count.

**5. Time and Space Complexity**

For each test case:

- Each feasibility check is $O(1)$ time.
- The doubling phase takes $O(\log n^*)$ checks.
- The binary search takes $O(\log n^*)$ checks.

Total time: $O(\log n^*)$ per test case, where $n^*$ is the minimum answer.  
Extra space: $O(1)$ aside from input reading and the output list.

**6. Conclusion**

By splitting movement by tick parity, replacing per-tick simulation with
constant-time capacity formulas, and using monotone binary search, the solution
computes the minimum ticks efficiently even for very large $(X, Y)$ and many
test cases.